# 第八章 多态
> “我曾被问到‘求教，Babbage先生，如果你向机器中输入错误的数字，可以得到正确的结果吗？’我无法恰当的解释产生这种问题的概念上的混淆”。

> 在面向对象的程序设计语言中，多态是继数据抽象和继承之后的第三种基本特征。

## 8.1 再论向上转型
### 8.1.1 忘记对象类型
> 写一个简单方法，它仅接受基类作为参数，而不是特殊的导出类。这样就不用写一堆方法来处理那些特殊的导出类了。

## 8.2 转机
### 8.2.1 方法调用绑定
> 采用后期绑定也叫动态绑定或运行时绑定。

> Java中只有static和final方法是前期绑定，其它都是后期绑定。这两个关键字可以有效的告诉编译器关闭后期绑定生成更有效率的方法，这就是为什么之前版本加上这两个关键字可以提高效率的原因。

### 8.2.2 产生正确的行为
> Java所有方法都是通过动态绑定实现多态。我们可以变现只与基类打交道的代码，并且对所有导出类都可以正确的运行。也就是发送消息给某个对象，让对象自己去判断应该做什么事。

### 8.2.3 可扩展性
> 由于有多态机制，我们可以根据自己需要对系统添加任意多的新类型，而不需要更改方法。这样程序是可扩展的，因为可以从通用的基类继承出新的数据类型，从而添加一些新的功能，那些操作基类接口的方法不需要做任何修改就可以应用于新类。

## 8.3 构造器和多态
> 构造器不同于其他方法，涉及到多态时仍是如此。构造器不具备多态性（构造器实际上是static方法，只不过是隐式的）。

### 8.3.1 构造器的调用顺序
> 构造器类总是在导出类的构造过程中调用，而且安装逐层次向上链接，已使每个基类的构造器都能得到调用。这样的好处是可以使得对象被正确完整的构造。

> 如果没有指定构造器。会使用默认构造器，如果默认构造器不存在，则会报错（某个类没有构造器，编译器会自动合成一个默认构造器）。

> 复杂对象调用构造器顺序
> * 调用基类构造器。这个步骤会不断递归，首先是构造这一层次的更，然后是下一级导出类，知道最底层的导出类。
> * 按声明顺序调用成员的初始化方法。
> * 调用导出类构造器的主体。

> 因为导出类中必须假定基类的所有成员是有效的，所以基类必须在导出类构造前构造。

### 8.3.2 继承与清理
> 通过组合和继承方法来创建新类时，永远不必担心对象的清理问题，子对象通常都会留给垃圾回收器进行处理。

### 8.3.3 构造器内部的多态方法的行为
> 初始化实际过程
> * 在其它任何事物发生之前，将分配给对象的存储空间初始化成二进制的零。
> * 如前所述的那样调用构造器。此时调用覆盖后的draw()方法（要在调用构造方法之前调用），由于第一步的原因我们会发radius值为0。
> * 按声明顺序调用成员的初始化方法。
> * 调用导出类构造器的主体。

> 这样做有一个优点，那就是所有的东西都初始化成零（或者是某些特殊类型中和“零”等价的值），而不是仅仅留作垃圾。如果有对象引用却没有初始化，就会在运行时出现异常。

> 编写构造器有一条有效的准则：“用尽可能简单的方法使对象进入正常状态，如果可以的话，避免调用其他方法”。

## 8.4 协变返回类型
> 他表示在导出类中被覆盖的方法可以返回基类方法返回类型的某种导出类型。

## 8.5 用继承进行设计
> 不要为了继承而继承。

> 一条通用的准则是：“用继承表达行为间的差异，并用字段表达状态上的变化”。

### 8.5.1 纯继承与扩展
> 纯继承是is-a，扩展是is-like-a。

> 纯继承可以认为是一种纯替代，因为导出类可以完全替代基类，在使用他们时，完全不需要知道子类的任何额外信息。

> 扩展可以有额外的特性和方法，但是导出类的扩展部分不能被基类访问。因此一旦向上转型我们就不能调用那些新方法。

### 8.5.1 向下转型与运行时类型识别
> 由于向上转型会失去具体的类信息，所以我们就想，通过向下转型--也就是在继承层次中向下移动--应该能获取类型信息。

> 但是向下转型是不安全的，所以所以向下转型否需要检查，如果类型不对会返回类转换异常。这种方式被称为：运行时类别识别。

## 8.6 总结



