# 第十二章 通过异常处理错误
> Java的基本理念是“结构不佳的代码不能运行”。

## 12.1 概念
> “异常”这个词有“我对此感到意外”的意思。问题出现，你也许不知道如何处理，但是你知道不能置之不理。你要看是不是有别人或者在别的地方能处理这个问题。现在只是在当前环境没有足够的信息处理这个问题，所以把这个问题提交到一个更高级别的环境中，在这里将作出正确的决定。

> 使用异常带来的另一个明显的好处是可以简化错误处理代码的复杂度。

## 12.2 基本异常
> 异常情形是指阻止当前方法或作用域继续执行的问题。例如除数为0。

> 异常最重要的方面之一就是如果发生问题，它们将不允许程序沿着其正常的路径继续走下去。

> 异常允许我们强制程序停止运行，并告诉我们出了什么问题，或者强制程序处理问题，并返回稳定状态。

### 12.2.1 异常参数
> 与Java其它对象一样，我们总是用new在堆上创建异常对象，这也伴随着存储空间的分配和构造器的调用。所有标准异常都有两个构造器：一个是默认构造器；另一个是接受字符串作为参数，以便能把相关信息放入异常对象的构造器。

> throw new NullPointException("t = null")

> 在使用new创建了异常对象之后，此对象将传给throw。尽管返回的异常对象类型与方法设计的返回类型不一致，但从效果看，他就想是从方法“返回”的。抛出异常与方法正常返回值的相似之处到此为止，因为异常返回的“地点”和方法正常返回的“地点”完全不同。

> Throwable都可以抛。

## 12.3 捕获异常
> 监控区域：他是一段可能产生异常的代码，并且后面跟着处理这些异常的代码。

### 12.3.1 try块
> 如果方法内部抛出了异常，那么方法将在抛出异常的过程中结束。要是不希望方法结束，可以在方法内部设置一个特殊块来捕获异常（关键字try）：

```java
	try {  
		// code that might generate exception  
	}
```

### 12.3.2 异常处理程序
> 抛出的异常必须在某处得到处理，这个地点就是异常处理程序，针对每个要处理的异常，得准备相应的处理程序（关键字catch）。

```java
	try {  
		// code that might generate exception  
	} catch(Type1 id1) {
		// handle exception of type1
	} catch(Type2 id2) {
		// handle exception of type2
	} catch(Type3 id3) {
		// handle exception of type3
	}
```

> 当异常被抛出时，异常处理机制近负责搜寻参数与异常类型相匹配的第一个处理程序。

### 12.3.2 终止与恢复
> 异常处理有两种模型：终止模型和恢复模型。

> java支持终止模型，这种模型中将假设错误非常关键，一旦异常被抛出，就表明错误无法挽回，也不能回来继续执行。

> 恢复模型意味着异常处理程序的作用是修正错误，然后重新调用出问题的方法，并认为第二次可以成功。Java如果要实现类似恢复的行为就不能抛出异常，而是调用方法来修正错误。

> 如果不是必须没有必要使用恢复模型，因为会导致代码的耦合带来维护的困难。

## 12.4 创建自定义异常
> 要自定义异常必须继承已有的异常类，最好是选择含义相近的已有异常。继承会创建默认构造器。

### 12.4.1 异常与日志记录
> 通常记录异常抛出处的栈轨迹。

## 12.5 异常说明
> Java鼓励人们把方法可能抛出的异常告知使用此方法的客户端程序员。

> 异常说明使用了附加关键字throws，后面接一个所有潜在异常类型的列表。

```java
	void function1() throws TooBig, TooSmall, DivZero{
		
	}
```

## 12.6 捕获所有异常
> 可以通过捕获基类Exception来做到这一点。

## 12.6.1 栈轨迹
> 可以通过getStackTrace()来直接访问，这个方法将返回一个由栈轨迹中的元素所构成的数组，其中每一个元素都表示栈中的一桢。

## 12.6.2 重新抛出异常
> 有时候希望重新将刚捕获的异常抛出，尤其是使用Exception时。

```java
	catch(Exception e){
		throw e;
	}
```

> 捕获异常后再抛出异常，有关原来异常发生点的信息会丢失，剩下的是与新异常抛出点有关的信息。

## 12.6.2 异常链
> 捕获一个异常后抛出另一个异常，并且希望将原始异常信息保存下来，这被称为异常链。

> Throwable的子类构造器可以接收一个cause对象作为参数，这个cause用来表示原始异常。这样把原始异常传递给新异常，即使在当前位置重新抛出了新异常，也能通过这个异常链追踪到异常最初发生的位置。

```java
	try {
		g();
	} catch (Exception e) {
		throw new RuntimeException(e);
	}
```

## 12.7 Java标准异常


## 12.8 使用finally进行清理


## 12.9 异常的限制


## 12.10 构造器


## 12.11 异常匹配


## 12.12 其他可选方式


## 12.13 异常使用指南


## 12.14 总结


